

// Used for creating unique support and marker names
A3A_supportCount = 0;
A3A_supportMarkerCount = 0;

// Array of active/recent supports
// used to limit resource spend in an area
// ["_side", "_callpos", "_targpos", "_resources", "_starttime"]
A3A_supportSpends = [];

// Individual strikes generated by supports (and other sources?) on creation
// used to prevent spamming same base type on a point or target
// target is object for TARGET base type, otherwise position
// power is effect radius for AREA, strength for TROOPS
// ["_side", "_basetype", "_target", "_endtime", "_duration", "_power"]
A3A_supportStrikes = [];

// only need this for the support system itself in this version?

// Active multitarget supports
// [_suppname, _side, _supptype, _center, _radius, _target, _minRadius (opt)]
// _target is [unit, position] array, or [] for free
A3A_activeSupports = [];

// Interfaces:
// Avail func: _weight = [_target, _side, _maxSpend?] call _availFunc;
// Create func:  _resCost = [_suppname, _side, _resPool, _maxSpend, _target, _targpos, _reveal, _delay] call _createFunc;

// Support types to use, base types and relative weights
A3A_supportTypesHM = createHashMapFromArray [
    // [supptype, [basetype, baseweight, effradius, strikepower]],
    // baseweight: Relative weighting for selection. May be adjusted by availability functions.
    // effradius: Strike radius, used for detecting friendly fire
    // strikepower: Approx resource value per strike for multi-target supports
    // can we remove this now that it's single-target? Add strikes in support instead?
    ["AIRSTRIKE",  ["AREA",   0.5, 150,   0]],              // balanced against carpetBombs (50/50 at tier 10), total will be 0.5
    ["ARTILLERY",  ["AREA",   0.5, 150,  85]],              // balanced against mortars, total will be 0.5
    ["MORTAR",     ["AREA",   0.5, 100,  50]],
    ["ASF",        ["TARGET", 1.0,   0, 100]],              // balanced against SAMs (if available), 66/33 weighting
    ["CAS",        ["TARGET", 1.0,   0, 100]],
    ["QRFLAND",    ["TROOPS", 1.0,   0,   0]],
    ["QRFAIR",     ["TROOPS", 0.5,   0,   0]]
];

if (allowUnfairSupports) then {
// well, everyone thinks gunships are unfair...
//    ["GUNSHIP",    ["AREA",   0.2,  50,   0]],                 // uh. Does AREA work for this? Only lasts 5 minutes so maybe...
    A3A_supportTypesHM set ["CARPETBOMBS",  ["AREA", 0.5, 200,   0]];     // balanced against airstrikes
    A3A_supportTypesHM set ["SAM",          ["TARGET", 1.0, 0, 100]];   // balanced against ASF
};
if (allowFuturisticSupports) then {
//    A3A_supportTypesHM set ["ORBITALSTRIKE", ["AREA", 0.1, 300, 0]];   // balanced against airstrikes?
};

// TODO: Define separate hashmap per side, pre-check for existence of vehicle supports?


// Build marker lists for determining importance of target locations

A3A_supportMarkersXYI = [];        // format [x, y, index into markerTypes]
A3A_supportMarkerTypes = [];     // format [markerName, markerType, hasRadio, defenceMul, ...]

#define RADIO_TOWER_BONUS 0.15

// Build arrays of markers that have defence bonuses
{ A3A_supportMarkerTypes pushBack [_x, "Airport", false, 1.0] } forEach airportsX;
{ A3A_supportMarkerTypes pushBack [_x, "Seaport", false, 0.6] } forEach seaports;
{ A3A_supportMarkerTypes pushBack [_x, "Outpost", false, 0.6] } forEach outposts;
{ A3A_supportMarkerTypes pushBack [_x, "Resource", false, 0.4] } forEach resourcesX;
{ A3A_supportMarkerTypes pushBack [_x, "Factory", false, 0.5] } forEach factories;
{ A3A_supportMarkerTypes pushBack [_x, "Town", false, 0.3] } forEach citiesX;
{
    _x pushBack (0.5 + random 0.5);         // current random defence multiplier
    private _pos = markerPos (_x#0);
    A3A_supportMarkersXYI pushBack [_pos#0, _pos#1, _forEachIndex];
} forEach A3A_supportMarkerTypes;

// Find nearest marker for each radio tower and mark it in markersDetail
{
    private _closeMrk = A3A_supportMarkersXYI inAreaArray [getPosATL _x, 500, 500];
    if (_closeMrk isEqualTo []) then { continue };
    private _nearest = [_closeMrk, _x] call BIS_fnc_nearestPosition;
    (A3A_supportMarkerTypes select (_nearest#2)) set [2, true];          // mark as having radio tower
} forEach (antennas + antennasDead);        // ugh

{
    // increase defenceMul if it's a radio tower
    if (_x#2) then { _x set [3, (_x#3) + RADIO_TOWER_BONUS] };
} forEach A3A_supportMarkerTypes;
